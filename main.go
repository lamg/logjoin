// Watches the changes in two log files generated by a proxy
// server and uses that information for generating a file with
// Common Log Format.
package main

import (
	"flag"
	"fmt"
	"github.com/hpcloud/tail"
	"io"
	"log"
	"os"
	"strconv"
	"unicode"
)

func main() {
	var lgn, dwn, out string
	flag.StringVar(&lgn, "f", "", "Logins log")
	flag.StringVar(&dwn, "d", "", "Downloads log")
	flag.StringVar(&out, "o", "", "Output log")
	var lgiTl, dwnTl *tail.Tail
	var e error
	lgiTl, e = tail.TailFile(lgn, tail.Config{Follow: true})
	if e == nil {
		dwnTl, e = tail.TailFile(dwn, tail.Config{Follow: true})
	}
	if e == nil {
		e = logLns(lgiTl.Lines, dwnTl.Lines, out)
	}
	if e != nil {
		log.Fatal(e.Error())
	}
}

func logLns(l, d chan *tail.Line, o string) (e error) {
	var oc <-chan string
	oc = joinLns(l, d)
	var f io.Writer
	f, e = os.Create(o)
	for e == nil {
		var s string
		s = <-oc
		_, e = f.Write([]byte(s))
	}
	return
}

type DLn struct {
	IP, URL string
	Dwn     int
}

func joinLns(l, d chan *tail.Line) (o chan string) {
	// { l contains lines with users associated to IP addresses
	//   and d contains lines with IP addresses associated to
	//   download requests }
	// { o contains lines with users associated to IP addresses
	//   and download requests }
	var lgi map[string]*LLn
	lgi = make(map[string]*LLn)
	for {
		var ll, dl *tail.Line
		ll, dl = <-l, <-d
		var lr *LLn
		var e error
		lr, e = parseLogins(ll.Text)
		if e == nil && lr.Action == "USERLOGIN" {
			lgi[lr.IP] = lr
		} else if e == nil && lr.Action == "DISCONNECT" {
			delete(lgi, lr.IP)
		}
		// { login info updated ≡ e = nil }
		var dr *DLn
		var ok bool
		dr, e = parseDownloads(dl.Text)
		if e == nil && lgi[dr.IP] != nil {
			// { user of dr founded }
			var s string
			s = toString(dr, lgi[dr.IP])
			o <- s
			// { line created and sent to channel o }
		}
	}
}

type LLn struct {
	Action, IP, User string
}

// { l has format:
//  line = month day time host pid zone action user cs ip.
//  month = word.
//  day = number.
//  time = number colon number colon number
//  host = word.
//  pid = word "[" number "]" colon.
//  zone = "Zone" colon word "-".
//  action = word [word] colon.
//  user = word comma comma.
//  ip = number dot number dot number dot number.
// }
func parseLogins(l string) (r *LLn, e error) {
	var i int
	i = 0
	if e == nil {
		i, e = skipWord(l, i)
	}
	// { month skipped ≡ e = nil }
	if e == nil {
		i, e = skipNumber(l, i)
	}
	// { day skipped ≡ e = nil }
	if e == nil {
		i, e = skipNumber(l, i)
	}
	if e == nil {
		i, e = skipChar(l, i, ':')
	}
	if e == nil {
		i, e = skipNumber(l, i)
	}
	if e == nil {
		i, e = skipChar(l, i, ':')
	}
	if e == nil {
		i, e = skipNumber(l, i)
	}
	// { time skipped ≡ e = nil }
	if e == nil {
		i, e = skipWord(l, i)
	}
	// { host skipped ≡ e = nil }
	if e == nil {
		i, e = skipWord(l, i)
	}
	if e == nil {
		i, e = skipChar(l, i, '[')
	}
	if e == nil {
		i, e = skipNumber(l, i)
	}
	if e == nil {
		i, e = skipChar(l, i, ']')
	}
	if e == nil {
		i, e = skipChar(l, i, ':')
	}
	if e == nil {
		i, e = skipWord(l, i)
	}
	if e == nil {
		i, e = skipChar(l, i, ':')
	}
	if e == nil {
		i, e = skipWord(l, i)
	}
	if e == nil {
		i, e = skipChar(l, i, '-')
	}
	// { zone skipped ≡ e = nil }
	var k int
	if e == nil {
		r = new(LLn)
		r.Action, k, e = getAction(l, i)
	}
	if e == nil {
		i = k
		r.User, k, e = getWord(l, i)
	}
	// { got user ≡ e = nil }
	if e == nil {
		i = k
		k, e = skipChar(l, i, ',')
	}
	if e == nil {
		i = k
		k, e = skipChar(l, i, ',')
	}
	// { ", ," skipped ≡ e = nil }
	if e == nil {
		i = k
		r.IP, k, e = getIP(l, i)
	}
	// { got IP ≡ e = nil }
	return
}

func getWord(s string, i int) (r string, k int, e error) {
	k = i
	for k != len(s) && (unicode.IsLetter(rune(s[k])) || s[k] == '-' || s[k] == '_') {
		k = k + 1
	}
	if k != len(s) && i != k {
		r = s[i:k]
		k = skipSpaces(s, k)
	} else {
		e = fmt.Errorf("Error in %s at %d", s, k)
	}
	return
}

func getIP(s string, i int) (r string, k int, e error) {
	k, e = skipDigits(s, i)
	if e == nil {
		r = s[i:k]
		i = k
		k, e = skipChar(s, i, '.')
	}
	if e == nil {
		r += "."
		i = k
		k, e = skipDigits(s, i)
	}
	if e == nil {
		r += s[i:k]
		i = k
		k, e = skipChar(s, i, '.')
	}
	if e == nil {
		r += "."
		i = k
		k, e = skipDigits(s, i)
	}
	if e == nil {
		r += s[i:k]
		i = k
		k, e = skipChar(s, i, '.')
	}
	if e == nil {
		r += "."
		i = k
		k, e = skipDigits(s, i)
	}
	if e == nil {
		r += s[i:k]
		k = skipSpaces(s, k)
	}
	return
}

func getAction(s string, i int) (r string, k int, e error) {
	r, k, e = getWord(s, i)
	if e == nil {
		i = k
		k, e = skipChar(s, i, ':')
	}
	if e != nil {
		i = skipSpaces(s, k)
		var r0 string
		r0, k, e = getWord(s, i)
		if e == nil {
			r = r + r0
			k, e = skipChar(s, k, ':')
		}
	}
	return
}

func skipChar(s string, i int, c rune) (r int, e error) {
	r = i
	if rune(s[i]) == c {
		r = i + 1
	} else {
		e = fmt.Errorf("Expected char %c at %d in %s", c, i, s)
	}
	r = skipSpaces(s, r)
	return
}

func skipDigits(s string, i int) (r int, e error) {
	r = i
	for r != len(s) && unicode.IsDigit(rune(s[r])) {
		r = r + 1
	}
	if r == i {
		e = fmt.Errorf("Error in %s at %d", s, i)
	}
	return
}

func skipNumber(s string, i int) (r int, e error) {
	r, e = skipDigits(s, i)
	if e == nil {
		r = skipSpaces(s, r)
	}
	return
}

// { 0 ≤ i < len(s) }
// { r = index of char seq followed by (letter seq followed by
//   space seq) }
func skipWord(s string, i int) (r int, e error) {
	r = i
	for r != len(s) && (unicode.IsLetter(rune(s[r])) || s[r] == '-' || s[r] == '_') {
		r = r + 1
	}
	if r == i {
		e = fmt.Errorf("Expected letter at %d in %s", i, s)
	} else {
		r = skipSpaces(s, r)
	}
	return
}

func skipSpaces(s string, i int) (r int) {
	for i != len(s) && unicode.IsSpace(rune(s[i])) {
		i = i + 1
	}
	r = i
	return
}

// { l has format:
//   line = number '.' number number ip word '/' number size
//      word url '-' word '/-' word '/' word.
// }
func parseDownloads(l string) (r *DLn, e error) {
	var i int
	i = 0
	i, e = skipNumber(l, i)
	if e == nil {
		i, e = skipChar(l, i, '.')
	}
	if e == nil {
		i, e = skipNumber(l, i)
	}
	if e == nil {
		i, e = skipNumber(l, i)
	}
	if e == nil {
		r = new(DLn)
		r.IP, i, e = getIP(l, i)
	}
	if e == nil {
		i = skipSpaces(l, i)
		i, e = skipWord(l, i)
	}
	if e == nil {
		i, e = skipChar(l, i, '/')
	}
	if e == nil {
		i, e = skipNumber(l, i)
	}
	var k int
	if e == nil {
		k, e = skipDigits(l, i)
	}
	if e == nil {
		var sz string
		sz = l[i:k]
		r.Dwn, e = strconv.Atoi(sz)
		k = skipSpaces(l, k)
	}
	if e == nil {
		i = k
		i, e = skipWord(l, i)
	}
	if e == nil {
		for i != len(l) && !unicode.IsSpace(rune(l[i])) {
			// { r.URL as a sequence of non-blank characters }
			r.URL, i = r.URL+string(l[i]), i+1
		}
		// { nothing more to parse }
	}

	return
}

func toString(d *DLn, l *LLn) (r string) {
	//TODO
	return
}
