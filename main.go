// Watches the changes in two log files generated by a
// proxy server and uses that information for generating a
// file with Apache Log format.
//
// Currently file "/var/log/squid/access.log" has a log of
// downloads, with IP address and time, but without the
// user name. It is needed a log file with downloads
// having IP, date, user name, size of downloaded data,
// and URL. Other fields may be included for conforming a
// specific log format, but the former are essential.
//
// Since the "/var/log/portalauth.log" logs the user name
// and its IP associated to events like login and
// disconnect, then it is possible to associate a user
// name to a download when the download's IP is equal to
// the user's IP, and when the download was made in a time
// between the user's login and the user's
// disconnect. This lapse of time is called a
// Session. With that information is possible generating
// the required log file.
package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"time"
)

func main() {
	var lgn, dwn, out string
	flag.StringVar(&lgn, "l", "", "Squid portalauth.log file path")
	flag.StringVar(&dwn, "d", "", "Squid access.log file path")
	flag.StringVar(&out, "o", "", "Output log file path (Apache log format). This file contains users associated to their respective downolads")
	flag.Parse()
	var e error
	var o *os.File
	o, e = os.Create(out)
	if e == nil {
		var ls, ds, oc chan string
		ls, ds, oc =
			make(chan string),
			make(chan string),
			make(chan string)
		go stringCh(lgn, ls)
		go stringCh(dwn, ds)
		go logProc(ls, ds, oc)
		var b bool
		b = true
		//{ b ≡ channel oc is open }
		for b {
			var s string
			s, b = <-oc
			_, e = o.Write([]byte(s))
			b = e == nil && b
		}
		o.Close()
	}
	if e != nil {
		log.Fatal(e.Error())
	}
	// { log written }
}

func stringCh(f string, ls chan<- string) {
	var r *os.File
	var e error
	r, e = os.Open(f)
	var sc *bufio.Scanner
	if e == nil {
		sc = bufio.NewScanner(r)
	}
	var b bool
	b = e == nil && sc.Scan()
	for b {
		ls <- sc.Text()
		b = sc.Scan()
	}
	close(ls)
	return
}

// { ll: channel of user events like 'USER LOGIN'
//      and 'DISCONNECT'
//   dl: channel of downloads
//   out: channel of downloads associated to users by
//        IP and time and other fields }
func logProc(ll, dl <-chan string, out chan<- string) {
	var e, d error
	var a, b bool
	var sm map[string][]*Session
	// { sm contains IPs associated to user sessions }
	var dm map[string][]*DLn
	// { dm contains IPs associated to downloads }
	sm, dm, a, b = make(map[string][]*Session),
		make(map[string][]*DLn),
		true, true
	for a || b {
		var lln *LLn
		var s string
		s, a = (<-ll)
		if a {
			lln, e = parseUsrEvt(s)
		}
		if a && e == nil {
			procUsrEvt(sm, lln)
			// { session opened or closed }
		}
		var dln *DLn
		s, b = <-dl
		if b {
			dln, d = parseDownload(s)
		}
		if b && d == nil {
			addDown(dm, sm, dln)
		}
		for k, _ := range sm {
			sendDwnAndClean(dm, sm, k, out)
		}
	}
	close(out)
}

func procUsrEvt(sm map[string][]*Session, lln *LLn) {
	if lln.IsLogin() {
		if sm[lln.IP] == nil {
			sm[lln.IP] = make([]*Session, 0)
		} else {
			var d time.Duration
			d, _ = time.ParseDuration("-1ms")
			closeSession(sm[lln.IP], lln.Time.Add(d))
		}
		sm[lln.IP] = append(sm[lln.IP], &Session{
			start:  lln.Time,
			user:   lln.User,
			closed: false,
		})
	} else if lln.IsLogout() {
		closeSession(sm[lln.IP], lln.Time)
	}
}

// Send downloads associated to users with sessions opened
// at the time the download was made, and with the same download
// IP.
func sendDwnAndClean(dm map[string][]*DLn, sm map[string][]*Session,
	ip string, out chan<- string) {
	if dm[ip] != nil {
		for k, l := range sm[ip] {
			var ds []*DLn
			ds = writeDownloads(l, dm[ip], out)
			if len(ds) < len(dm[ip]) {
				// { sm[ip][k] made downloads and that equivales
				//   to the previous sessions to k in sm[ip] cannot
				//   make downloads }
				sm[ip] = sm[ip][k:]
				// { previous sessions to k in sm[ip] are deleted
				//   from sm[ip] }
			}
			dm[ip] = ds
		}
	}
	return
}

func writeDownloads(s *Session, ds []*DLn,
	out chan<- string) (rs []*DLn) {
	// { rs is the remaining downloads ∧ t is the time.Time
	//   of the last download }
	rs = make([]*DLn, 0, len(ds))
	for _, j := range ds {
		var b, c bool
		b, c = s.start.Before(j.Time), s.end.After(j.Time)
		if b && c {
			out <- downloadToString(s, j)
		} else {
			rs = append(rs, j)
		}
	}
	return
}

func closeSession(s []*Session, t time.Time) {
	if len(s) != 0 && !s[len(s)-1].closed {
		s[len(s)-1].end = t
		s[len(s)-1].closed = true
	}
}

func addDown(dm map[string][]*DLn, sm map[string][]*Session,
	dln *DLn) {
	if dm[dln.IP] == nil {
		dm[dln.IP] = make([]*DLn, 0)
	}
	dm[dln.IP] = append(dm[dln.IP], dln)
}

func downloadToString(j *Session, k *DLn) (s string) {
	s = fmt.Sprintf(
		"%s - %s [%s] \"%s %s HTTP/1.0\" 200 %d\n",
		k.IP, j.user, k.Time.Format(time.RubyDate), k.Method, k.URL,
		k.Dwn,
	)
	return
}
