// Watches the changes in two log files generated by a
// proxy server and uses that information for generating a
// file with Apache Log format.
//
// Currently file "/var/log/squid/access.log" has a log of
// downloads, with IP address and time, but without the
// user name. It is needed a log file with downloads
// having IP, date, user, size of downloaded data, and
// URL. Other fields may be included for conforming a
// specific log format, but the former are essential.
//
// Since the "/var/log/portalauth.log" logs the user's
// name and its IP associated to events like login and
// disconnect, then it is possible to associate a user's
// name to a download when the download's IP is equal to
// the user's IP, and when the download was made in a time
// between the user's login and the user's
// disconnect. This lapse of time is called a
// Session. With that information is possible generating
// the required log file.
package main

import (
	"flag"
	"fmt"
	"github.com/hpcloud/tail"
	"os"
	"strconv"
	"time"
	"unicode"
)

func main() {
	var lgn, dwn, out string
	flag.StringVar(&lgn, "l", "", "Squid portalauth.log file path")
	flag.StringVar(&dwn, "d", "", "Squid access.log file path")
	flag.StringVar(&out, "o", "", "Output log file path (Apache log format). This file contains users associated to their respective downolads")
	flag.Parse()
	var lt, dt *tail.Tail
	var e error
	lt, e = tail.TailFile(lgn, tail.Config{Follow: true})
	if e == nil {
		dt, e = tail.TailFile(dwn, tail.Config{Follow: true})
	}
	var o *os.File
	if e == nil {
		o, e = os.Create(out)
	}
	if e == nil {
		var ls, ds, oc chan string
		ls, ds, oc = make(chan string), make(chan string),
			make(chan string)
		go stringCh(lt.Lines, ls)
		go stringCh(dt.Lines, ds)
		go logProc(ls, ds, oc)
		var b bool
		b = true
		//{ b ≡ channel oc is open }
		for b {
			var s string
			s, b = <-oc
			_, e = o.Write([]byte(s))
			o.Sync()
			b = e == nil && b
		}
		o.Close()
	}
}

func stringCh(ll <-chan *tail.Line, ls chan<- string) {
	var b bool
	b = true
	for b {
		var s *tail.Line
		s, b = <-ll
		if b {
			ls <- s.Text
		}
	}
	close(ls)
	return
}

// { ll: channel of user events like 'USER LOGIN'
//      and 'DISCONNECT'
//   dl: channel of downloads
//   out: channel of downloads associated to users by
//        IP and time and other fields }
func logProc(ll, dl <-chan string, out chan<- string) {
	var e, d error
	var a, b bool
	var sm map[string][]*Session
	// { sm contains IPs associated to user sessions }
	var dm map[string][]*DLn
	// { dm contains IPs associated to downloads }
	sm, dm, a, b = make(map[string][]*Session),
		make(map[string][]*DLn),
		true, true
	for a || b {
		var lln *LLn
		var s string
		s, a = (<-ll)
		if a {
			lln, e = parseUsrEvt(s)
		}
		if a && e == nil {
			procUsrEvt(sm, lln)
			// { session opened or closed }
		}
		var dln *DLn
		s, b = <-dl
		if b {
			dln, d = parseDownload(s)
		}
		if b && d == nil {
			addDown(dm, sm, dln)
		}
		for k, _ := range sm {
			sendDwnAndClean(dm, sm, k, out)
		}
	}
	close(out)
}

func addDown(dm map[string][]*DLn, sm map[string][]*Session,
	dln *DLn) {
	if dm[dln.IP] == nil {
		dm[dln.IP] = make([]*DLn, 0)
	}
	dm[dln.IP] = append(dm[dln.IP], dln)
}

// Send downloads associated to users with sessions opened
// at the time the download was made, and with the same download
// IP.
func sendDwnAndClean(dm map[string][]*DLn, sm map[string][]*Session,
	ip string, out chan<- string) {
	if dm[ip] != nil {
		for k, l := range sm[ip] {
			var ds []*DLn
			ds = writeDownloads(l, dm[ip], out)
			if len(ds) < len(dm[ip]) {
				// { sm[ip][k] made downloads and that equivales
				//   to the previous sessions to k in sm[ip] cannot
				//   make downloads }
				sm[ip] = sm[ip][k:]
				// { previous sessions to k in sm[ip] are deleted
				//   from sm[ip] }
			}
			dm[ip] = ds
		}
	}
	return
}

func writeDownloads(s *Session, ds []*DLn,
	out chan<- string) (rs []*DLn) {
	// { rs is the remaining downloads ∧ t is the time.Time
	//   of the last download }
	rs = make([]*DLn, 0, len(ds))
	for _, j := range ds {
		var b, c bool
		b, c = s.start.Before(j.Time), s.end.After(j.Time)
		if b && c {
			out <- downloadToString(s, j)
		} else {
			rs = append(rs, j)
		}
	}
	return
}

func downloadToString(j *Session, k *DLn) (s string) {
	s = fmt.Sprintf(
		"%s - %s [%s] \"%s %s HTTP/1.0\" 200 %d\n",
		k.IP, j.user, k.Time.Format(time.RubyDate), k.Method, k.URL,
		k.Dwn,
	)
	return
}

func procUsrEvt(sm map[string][]*Session, lln *LLn) {
	if lln.IsLogin() {
		if sm[lln.IP] == nil {
			sm[lln.IP] = make([]*Session, 0)
		} else {
			var d time.Duration
			d, _ = time.ParseDuration("-1ms")
			closeSession(sm[lln.IP][len(sm[lln.IP])-1],
				lln.Time.Add(d))
		}
		sm[lln.IP] = append(sm[lln.IP], &Session{
			start:  lln.Time,
			user:   lln.User,
			closed: false,
		})
	} else if lln.IsLogout() {
		closeSession(sm[lln.IP][len(sm[lln.IP])-1], lln.Time)
	}
}

func closeSession(s *Session, t time.Time) {
	s.end = t
	s.closed = true
}

type DLn struct {
	IP, URL, Method string
	Dwn             int
	Time            time.Time
	Written         bool
}

type Session struct {
	user       string
	start, end time.Time
	closed     bool
}

type LLn struct {
	Action, IP, User string
	Time             time.Time
}

func (l *LLn) IsLogin() (b bool) {
	b = l.Action == "USERLOGIN"
	return
}

func (l *LLn) IsLogout() (b bool) {
	b = l.Action == "DISCONNECT"
	return
}

// { l has format:
//  line = month day time host pid zone action user cs ip.
//  month = word.
//  day = number.
//  time = number colon number colon number
//  host = word.
//  pid = word "[" number "]" colon.
//  zone = "Zone" colon word "-".
//  action = word [word] colon.
//  user = word comma comma.
//  ip = number dot number dot number dot number.
// }
func parseUsrEvt(l string) (r *LLn, e error) {
	var i int
	i, r = 0, new(LLn)
	if e == nil {
		i, e = skipWord(l, i)
	}
	// { month skipped ≡ e = nil }
	if e == nil {
		i, e = skipNumber(l, i)
	}
	// { day skipped ≡ e = nil }
	if e == nil {
		i, e = skipNumber(l, i)
	}
	if e == nil {
		i, e = skipChar(l, i, ':')
	}
	if e == nil {
		i, e = skipNumber(l, i)
	}
	if e == nil {
		i, e = skipChar(l, i, ':')
	}
	if e == nil {
		i, e = skipDigits(l, i)
	}
	if e == nil {
		r.Time, e = time.ParseInLocation(time.Stamp, l[:i],
			time.Now().Location())
	}
	// { time skipped ≡ e = nil }
	if e == nil {
		r.Time = r.Time.AddDate(time.Now().Year(), 0, 0)
		i = skipSpaces(l, i)
		i, e = skipWord(l, i)
	}
	// { host skipped ≡ e = nil }
	if e == nil {
		i, e = skipWord(l, i)
	}
	if e == nil {
		i, e = skipChar(l, i, '[')
	}
	if e == nil {
		i, e = skipNumber(l, i)
	}
	if e == nil {
		i, e = skipChar(l, i, ']')
	}
	if e == nil {
		i, e = skipChar(l, i, ':')
	}
	if e == nil {
		i, e = skipWord(l, i)
	}
	if e == nil {
		i, e = skipChar(l, i, ':')
	}
	if e == nil {
		i, e = skipWord(l, i)
	}
	if e == nil {
		i, e = skipChar(l, i, '-')
	}
	// { zone skipped ≡ e = nil }
	if e == nil {
		r.Action, i, e = getAction(l, i)
	}
	if e == nil {
		r.User, i, e = getWord(l, i)
	}
	// { got user ≡ e = nil }
	if e == nil {
		i, e = skipChar(l, i, ',')
	}
	if e == nil {
		i, e = skipChar(l, i, ',')
	}
	// { ", ," skipped ≡ e = nil }
	if e == nil {
		r.IP, i, e = getIP(l, i)
	}
	// { got IP ≡ e = nil }
	return
}

func getWord(s string, i int) (r string, k int, e error) {
	k = i
	for k != len(s) && (unicode.IsLetter(rune(s[k])) ||
		s[k] == '-' || s[k] == '_') {
		k = k + 1
	}
	if k != len(s) && i != k {
		r = s[i:k]
		k = skipSpaces(s, k)
	} else {
		e = fmt.Errorf("Error in %s at %d", s, k)
	}
	return
}

func getIP(s string, i int) (r string, k int, e error) {
	k, e = skipDigits(s, i)
	if e == nil {
		r = s[i:k]
		i = k
		k, e = skipChar(s, i, '.')
	}
	if e == nil {
		r += "."
		i = k
		k, e = skipDigits(s, i)
	}
	if e == nil {
		r += s[i:k]
		i = k
		k, e = skipChar(s, i, '.')
	}
	if e == nil {
		r += "."
		i = k
		k, e = skipDigits(s, i)
	}
	if e == nil {
		r += s[i:k]
		i = k
		k, e = skipChar(s, i, '.')
	}
	if e == nil {
		r += "."
		i = k
		k, e = skipDigits(s, i)
	}
	if e == nil {
		r += s[i:k]
		k = skipSpaces(s, k)
	}
	return
}

func getAction(s string, i int) (r string, k int, e error) {
	r, k, e = getWord(s, i)
	if e == nil {
		i = k
		k, e = skipChar(s, i, ':')
	}
	if e != nil {
		i = skipSpaces(s, k)
		var r0 string
		r0, k, e = getWord(s, i)
		if e == nil {
			r = r + r0
			k, e = skipChar(s, k, ':')
		}
	}
	return
}

func skipChar(s string, i int, c rune) (r int, e error) {
	r = i
	if rune(s[i]) == c {
		r = i + 1
	} else {
		e = fmt.Errorf("Expected char %c at %d in %s", c, i, s)
	}
	r = skipSpaces(s, r)
	return
}

func skipDigits(s string, i int) (r int, e error) {
	r = i
	for r != len(s) && unicode.IsDigit(rune(s[r])) {
		r = r + 1
	}
	if r == i {
		e = fmt.Errorf("Error in %s at %d", s, i)
	}
	return
}

func skipNumber(s string, i int) (r int, e error) {
	r, e = skipDigits(s, i)
	if e == nil {
		r = skipSpaces(s, r)
	}
	return
}

// { 0 ≤ i < len(s) }
// { r = index of char seq followed by (letter seq followed by
//   space seq) }
func skipWord(s string, i int) (r int, e error) {
	r = i
	for r != len(s) && (unicode.IsLetter(rune(s[r])) || s[r] == '-' || s[r] == '_') {
		r = r + 1
	}
	if r == i {
		e = fmt.Errorf("Expected letter at %d in %s", i, s)
	} else {
		r = skipSpaces(s, r)
	}
	return
}

func skipSpaces(s string, i int) (r int) {
	for i != len(s) && unicode.IsSpace(rune(s[i])) {
		i = i + 1
	}
	r = i
	return
}

func getTime(l string, i int) (t time.Time, k int, e error) {
	var r int64
	k, e = skipDigits(l, i)
	if e == nil {
		r, e = strconv.ParseInt(l[i:k], 10, 64)
	}
	if e == nil {
		k, e = skipChar(l, k, '.')
	}
	if e == nil {
		i = k
		k, e = skipDigits(l, i)
	}
	var ms int64
	if e == nil {
		ms, e = strconv.ParseInt(l[i:k], 10, 64)
	}
	if e == nil {
		k = skipSpaces(l, k)
		t = time.Unix(r, ms*1000000)
	}
	return
}

// { l has format:
//   line = number '.' number number ip word '/' number size
//      word url '-' word '/-' word '/' word.
// }
func parseDownload(l string) (r *DLn, e error) {
	var i int
	r = &DLn{Written: false}
	i = 0
	r.Time, i, e = getTime(l, i)
	if e == nil {
		i, e = skipNumber(l, i)
	}
	if e == nil {
		r.IP, i, e = getIP(l, i)
	}
	if e == nil {
		i = skipSpaces(l, i)
		i, e = skipWord(l, i)
	}
	if e == nil {
		i, e = skipChar(l, i, '/')
	}
	if e == nil {
		i, e = skipNumber(l, i)
	}
	var k int
	if e == nil {
		k, e = skipDigits(l, i)
	}
	if e == nil {
		var sz string
		sz = l[i:k]
		r.Dwn, e = strconv.Atoi(sz)
		k = skipSpaces(l, k)
	}
	if e == nil {
		i = k
		r.Method, i, e = getWord(l, i)
		// { got Method }
	}
	if e == nil {
		for i != len(l) && !unicode.IsSpace(rune(l[i])) {
			// { r.URL as a sequence of non-blank characters }
			r.URL, i = r.URL+string(l[i]), i+1
		}
		// { nothing more to parse }
	}
	return
}
