// Watches the changes in two log files generated by a proxy
// server and uses that information for generating a file with
// Squid log's format.
package main

import (
	"flag"
	"github.com/hpcloud/tail"
	"log"
)

func main() {
	var lgn, dwn, out string
	flag.StringVar(&lgn, "f", "", "Logins log")
	flag.StringVar(&dwn, "d", "", "Downloads log")
	flag.StringVar(&out, "o", "", "Output log")
	var lgiTl, dwnTl *tail.Tail
	var e error
	lgiTl, e = tail.TailFile(lgn, tail.Config{Follow: true})
	if e == nil {
		dwnTl, e = tail.TailFile(dwn, tail.Config{Follow: true})
	}
	if e == nil {
		e = logLns(lgiTl.Lines, dwnTl.Lines, out)
	}
	if e != nil {
		log.Fatal(e.Error())
	}
}

func logLns(l, d chan *tail.Line, o string) (e error) {
	var oc chan<- string
	oc = joinLns(l, d)
	var f io.Writer
	f, e = os.Create(o)
	for e == nil {
		var s string
		s = <-oc
		_, e = f.Write([]byte(s))
	}
	return
}

func joinLns(l, d chan *tail.Line) (o chan string) {
	// { l contains lines with users associated to IP addresses
	//   and d contains lines with IP addresses associated to
	//   download requests }
	// { o contains lines with users associated to IP addresses
	//   and download requests }
	var lgi map[string]*LLn
	lgi = make(map[string]*LLn)
	for {
		var ll, dl *tail.Line
		ll, dl = <-l, <-d
		var lr *LLn
		var e error
		lr, e = parseLogins(ll.Text)
		if e == nil && lr.Login {
			lgi[lr.IP] = lr
		} else if e == nil && lr.Logout {
			delete(lgi[lr.IP])
		}
		// { login info updated â‰¡ e = nil }
		var dr *DLn
		var ok bool
		dr, e = parseDownloads(dl.Text)
		if _, ok = lgi[dr.IP]; e == nil && ok {
			// { user of dr founded }
			var s string
			s = toString(dr, lgi[dr.IP])
			o <- s
			// { line created and sent to channel o }
		}
	}
}

//TODO
func parseLogins(l string) (r *LLn, e error) {
	return
}

func parseDownloads(l string) (r *DLn, e error) {
	return
}

func toString(d *DLn, l *LLn) (r string) {
	return
}
